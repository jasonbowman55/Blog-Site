---
title: "The Advanced Encryption Standard"
description: "Lab 7"
author: "Jason Bowman"
date: "10-30-24"
categories:
  - Reflection
  - Lab Report
draft: false
code-links:
  - icon: github
    text: Lab 7 GitHub
    href: https://github.com/jasonbowman55/microP-lab7.git
---

# Intro & Design Approach
The Advanced Encryption Standard (AES) is a widely accepted and NSA-recommended encryption standard for protecting sensitive data, including classified government information. AES-128, used in this lab, is the smallest variant of AES, utilizing 128-bit keys and internal logic. In contrast, newer versions, AES-192 and AES-256, offer higher security levels by using longer key lengths, though all variants operate similarly.

This lab involves implementing the AES algorithm on our UPduino v3.1 UP5K FPGA using SystemVerilog. To maximize efficiency and minimize storage usage, we applied a pipelining method throughout the process. A simple testbench was created for this lab, where our STM32 MCU sends plaintext and a key to the FPGA over SPI. If the FPGA returns the correct ciphertext, an onboard LED is turned on to indicate success.

![Figure1: Top level AES-128 functionality](images/aes-128.jpeg)

# AES-128 Functionality
*this section provides an overview of the AES-128 algorithm, and will be referenced in the design section*

## Key Schedule
The key schedule in AES-128, also known as key expansion, is an essential part of the encryption process. It generates a unique 128-bit round key for each of the 10 rounds, based on the original 128-bit cipher key. The key schedule works through several steps:

**Rot Word:** This operation rotates a four-byte word by shifting each byte one position to the left, which helps introduce diffusion.

![Figure2: RotWord step in Key Expansion](images/rot_word.jpeg)

**Sub Word:** Each byte in the word undergoes an S-box substitution, adding nonlinearity to the key schedule. In this substitution, each byte's value is mapped to a new value by treating the byte as coordinates (x, y) in the S-box grid. The byte is then replaced with the value at the corresponding position in the S-box table.

![Figure3: SubWord step in Key Expansion](images/sbox.jpeg)

**Rcon:** A round constant specific to each round is XORed with the first word of each four-word block, ensuring each round key is unique.

![Figure4: Rcon step in Key Expansion](images/rcon.jpeg)

**Fill Round Key:** The remaining words of each round key are derived by XORing parts of the previous round key, filling out the key material for each round. This is done recusively, as each round is XORed with the previous output from the recursive XOR. This is done until a new round key is produced.

![Figure5: Recursive XOR (aka Fill Round Key) step in Key Expansion](images/recursive_xor.jpeg)

As each new round key is created, it is then used as the basis for generating the next round key. The first word of the new round key goes through the RotWord transformation, followed by other steps in the key expansion process, ensuring that each subsequent round key is derived from the previous one in a recursive, circular fashion. This process continues until all round keys are generated for the encryption.

## Encryption Process
The encryption process is classified as all of the sequential and combinational logic performed on the cyhertext, and intermediate versions of that cyphertext, throughout all rounds in the full AES-128 encryption standard. This process depends on the current round key, which is generated in parallel with the encryption process ensuring that the correct round key is used for its intended encryption round.

**Sub Bytes:** Similar to Su bWord in the key expansion process, however each byte in the full 128-bit cyphertext undergoes an S-box substitution, adding nonlinearity to the key schedule. Each byte's value is mapped to a new value by treating the byte as coordinates (x, y) in the S-box grid, as done in Figure 3 under key schedule.

**Shift Rows:** Each row in the 4x4, byte-wise, column-major representation of the 128-bit ciphertext is shifted left by one byte, with any overflow bytes wrapping around to the right side sequentially.

![Figure6: Shift Rows step in the encryption process](images/shift_rows.jpeg)

**Mix Cols:** Each column of the 4x4 byte matrix is transformed using Galois Field (GF(2^8)) arithmetic to mix and spread out the bytes, enhancing diffusion in the encryption.

![Figure7: Mix Cols step in the encryption process](images/mix_cols.jpeg)

**Add Round Key:** This step combines the current ciphertext with the current round key using an XOR operation, ensuring all round keys are unique.

![Figure8: Add Ronnd Key step to the encryption process](images/add_round_key.jpeg)

## AES-128 Note
It is important to note that not all rounds of the  AES-128 encrption standard are the same, in particular the first and last round. For informaiton and helpful demonstration of all related steps of AES-128, [see this website.](https://legacy.cryptool.org/en/cto/aes-animation)

# Design
*This section goes into the hardware and software design specifics*

## Hardware
**This will be written after it is connected to the MCU**

## Software
The scope of this lab focused on using the FPGA and SystemVerilog to implement AES-128 encryption. A pipelined design, illustrated in Figure 9 below, was chosen for its ability to store intermediate values between rounds using buffer flip-flops. A timer introduced necessary delays between rounds, ensuring sufficient propagation time through each step of the Key Schedule and Encryption Process.

![Figure9: Block Diagram](images/main_bd.jpeg)

The block diagram shows various source signals (in blue) and enable signals (in red), which determine the selection of intermediate versions of the ciphertext or plaintext, as well as the specific round key or original key in use. Each enable signal is configured to store values at the end of 5 clock cycles, providing sufficient propagation time for calculations as previously mentioned. Each round can be represented as shown in Figure 10, with each state labeled as "S", meaning state, followed by the round number.

The communication protocol between the FPGA and MCU uses SPI. It operates by pulling the "load" signal from 1 to 0 once the full initial plaintext and key are ready to be read by the FPGA. The "done" signal is asserted when the final ciphertext is produced by the FPGA and is available to be read by the MCU. At this point, internal logic on the MCU checks whether the received ciphertext matches the expected value, toggling an onboard LED based on the outcome of the comparison.

![Figure10: FSM](images/fsm.jpeg)

# Results
This lab resulted in a functional implementation of the AES-128 algorithm on the UPduino v3.1 UP5K FPGA, which passed both the provided encryption process and SPI functionality test benches. The implementation was successfully deployed on hardware, enabling effective communication with the onboard STM32 MCU via SPI on the Micro-Ps protoboard. The system also passed the internal check, causing the PA9 onboard LED to illuminate upon currect encryption. This lab took approximately 22 hours to complete.

## Simulation Results

## Hardware Results

# Reflection
This lab acted as kind of a cummilitive project for a lot of my SystemVerilog and FPGA knowledge. I really enjoyed the implamentation and the final product of this lab as it shows just how powerful these micro chips can be, and I was able to learn about AES-128. I think this was a great lab to end the lab portion of Micro Ps on and I am extremely excited to apply this knowledge into my final project.
