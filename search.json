[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "My Portfolio",
    "section": "",
    "text": "Course Website"
  },
  {
    "objectID": "MicroP/lab_reflect/lab2/lab2.html",
    "href": "MicroP/lab_reflect/lab2/lab2.html",
    "title": "Time-Multiplexed Dual 7-Segment Display",
    "section": "",
    "text": "In this lab, a design was implemented on an FPGA to time-multiplex between two 7-segment displays, each showing separate values based on its own 4-bit binary input. Two simple transistor circuits were used to alternate between the respective 7-segment displays. Additionally, the design required the sum of these two 4-bit inputs to be displayed in binary on a 5-bit line of LEDs.\n\n\n\nHardware for Lab 2 including time-multiplexed dual 7-segment display and 5-bit binary LED line\n\n\nMy design approach began with a block diagram, where I created a top module and two submodules: one controlled both 7-segment displays, and the other controlled the line of 5 independent LEDs.\n\n\n\n\n\nThis block diagram outlines the SystemVerilog modules used in lab 2\n\n\nIn SystemVerilog, when programming the UPduino FPGA, a counter was used in conjunction with the on-board high-speed oscillator (HSOSC) to generate an internal clock signal named int_osc. This int_osc influenced the counter variable, and was then used to alternate between the displays and manage other internal logic. Combinational logic was subsequently implemented to handle the 7-segment display outputs. The oscillatory behavior of the int_osc signal was used to toggle the I/Os for each independent 7-segment display. A simple assign statement was used to generate the LED binary outputs.\n\n\n\n\n\n\nThis circuit schematic shows the hardware connections, related pins, and corresponding SystemVerilog signals"
  },
  {
    "objectID": "MicroP/lab_reflect/lab2/lab2.html#intro-design-approach",
    "href": "MicroP/lab_reflect/lab2/lab2.html#intro-design-approach",
    "title": "Time-Multiplexed Dual 7-Segment Display",
    "section": "",
    "text": "In this lab, a design was implemented on an FPGA to time-multiplex between two 7-segment displays, each showing separate values based on its own 4-bit binary input. Two simple transistor circuits were used to alternate between the respective 7-segment displays. Additionally, the design required the sum of these two 4-bit inputs to be displayed in binary on a 5-bit line of LEDs.\n\n\n\nHardware for Lab 2 including time-multiplexed dual 7-segment display and 5-bit binary LED line\n\n\nMy design approach began with a block diagram, where I created a top module and two submodules: one controlled both 7-segment displays, and the other controlled the line of 5 independent LEDs.\n\n\n\n\n\nThis block diagram outlines the SystemVerilog modules used in lab 2\n\n\nIn SystemVerilog, when programming the UPduino FPGA, a counter was used in conjunction with the on-board high-speed oscillator (HSOSC) to generate an internal clock signal named int_osc. This int_osc influenced the counter variable, and was then used to alternate between the displays and manage other internal logic. Combinational logic was subsequently implemented to handle the 7-segment display outputs. The oscillatory behavior of the int_osc signal was used to toggle the I/Os for each independent 7-segment display. A simple assign statement was used to generate the LED binary outputs.\n\n\n\n\n\n\nThis circuit schematic shows the hardware connections, related pins, and corresponding SystemVerilog signals"
  },
  {
    "objectID": "MicroP/lab_reflect/lab2/lab2.html#results-discussion",
    "href": "MicroP/lab_reflect/lab2/lab2.html#results-discussion",
    "title": "Time-Multiplexed Dual 7-Segment Display",
    "section": "Results & Discussion",
    "text": "Results & Discussion\nThis lab resulted in a working time-multiplexed dual 7-segment display that coorectly displays hexidecimal digits 1-F independantly, clearly, and without bleeding. As well as a functioning 5-bit LED display showing the binary combination of the two 4-bit inputs.\nThe counter variable, incremented by the internal clock signal (int_osc), controls the oscillation speed between two different 7-segment displays using a selector. While this provides adequate control for the current application, developing a more precise counter mechanism could further optimize performance and improve accuracy in future work.\nThis lab took approximately 13 hours to complete. Significant challenges were encountered early in the implementation stage, and using test benches could have helped reduce the time spent."
  },
  {
    "objectID": "MicroP/lab_reflect/lab2/lab2.html#for-the-future",
    "href": "MicroP/lab_reflect/lab2/lab2.html#for-the-future",
    "title": "Time-Multiplexed Dual 7-Segment Display",
    "section": "For The future",
    "text": "For The future\n\nLearn and implament test benches in order to miniimize time wasted\nCreate a more clear and concise circuit schematic that is easier to follow when building the circuit."
  },
  {
    "objectID": "MicroP/lab_reflect/first-post.html",
    "href": "MicroP/lab_reflect/first-post.html",
    "title": "First Post",
    "section": "",
    "text": "My goals for Micro-Ps include higher software proficiency and ability to understand FPGA and Micro Processor functionalities based on thei respective data sheets."
  },
  {
    "objectID": "MicroP/index.html",
    "href": "MicroP/index.html",
    "title": "Lab Reflections",
    "section": "",
    "text": "FPGA and MCU Setup and Testing\n\n\n\n\n\nLab 1\n\n\n\n\n\nSep 9, 2024\n\n\nJason Bowman\n\n\n\n\n\n\n\n\n\n\n\n\nTime-Multiplexed Dual 7-Segment Display\n\n\n\n\n\nLab 2\n\n\n\n\n\nSep 9, 2024\n\n\nJason Bowman\n\n\n\n\n\n\n\n\n\n\n\n\nKeypad Scanner\n\n\n\n\n\nLab 3\n\n\n\n\n\nSep 9, 2024\n\n\nJason Bowman\n\n\n\n\n\n\n\n\n\n\n\n\nDigital Audio\n\n\n\n\n\nLab 4\n\n\n\n\n\nSep 9, 2024\n\n\nJason Bowman\n\n\n\n\n\n\n\n\n\n\n\n\nInterrupts\n\n\n\n\n\nLab 5\n\n\n\n\n\nSep 9, 2024\n\n\nJason Bowman\n\n\n\n\n\n\n\n\n\n\n\n\nThe Internet of Things and Serial Peripheral Interface\n\n\n\n\n\nLab 6\n\n\n\n\n\nSep 9, 2024\n\n\nJason Bowman\n\n\n\n\n\n\n\n\n\n\n\n\nThe Advanced Encryption Standard\n\n\n\n\n\nLab 7\n\n\n\n\n\nSep 9, 2024\n\n\nJason Bowman\n\n\n\n\n\n\n\n\n\n\n\n\nFirst Post\n\n\n\n\n\nInitial learning goals\n\n\n\n\n\nAug 30, 2024\n\n\nJason Bowman\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "HPR/index.html",
    "href": "HPR/index.html",
    "title": "High Power Rocketry",
    "section": "",
    "text": "About\nThis class was a thrilling rollercoaster experience during my junior year at Harvey Mudd College. This page mainly focuses on the final project portion of the class, where Jordan Stone and I built a PID-controlled rotational stabilization system for a Level 2 high-power model rocket that reached an altitude of 3,000 meters. Throughout this project, I gained extensive knowledge in digital electronics, signal and data processing, control systems, mechanical design, project management, and rigorous testing procedures. I also learned that I really, really, really like to launch rockets and see if my creation can survive the flight environments.\n\n\nProject Ideation\nOur project search was kind of all over the place. We had thoughts of dual stage rockets, modal analysis, top speed, max height. Until we found that someone in a previous class attempted a “Gyro Stabilized” rocket, which resulted in the following comment. “Got the gyro to spin up, but it didn’t seem to have much effect.” -E178: High-Power Rocketry/Final Project So we thought, what is stopping up from building a active control system in order to rotationally stabilize our rocket.\n\nLaunch Day\n\n\n\nJ&J rocket (Jordan & Jason)\n\n\nStructure: intro / about initial thoughts and ideas why we chose what we wanted too what rocket we used electronics mechanical design flight day fnal presentation / paper\nBringing an idea into flurission, in my experience, typically come with extra nick nacks and trinquets than I initially imagine."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome!",
    "section": "",
    "text": "Hi, I am Jason Bowman. I am a Senior Engineering major at Harvey Mudd College, with a concentration in Russian language. I have technical experience with Embedded Systems Engineering, Mechanical Design and SolidWorks CAD design and simulation, and Control Systems to name a few.\nThis portfolio began as a means of displaying progress in a class called Micro Processor Application & Design (aka “Micro Ps”)."
  },
  {
    "objectID": "MicroP/lab_descript/microp_lab_descriptions.html#lab-2-multiplexed-7-segment-display",
    "href": "MicroP/lab_descript/microp_lab_descriptions.html#lab-2-multiplexed-7-segment-display",
    "title": "My Portfolio",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "MicroP/lab_descript/microp_lab_descriptions.html#lab-3-keypad-scanner",
    "href": "MicroP/lab_descript/microp_lab_descriptions.html#lab-3-keypad-scanner",
    "title": "My Portfolio",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "MicroP/lab_descript/microp_lab_descriptions.html#lab-4-digital-audio",
    "href": "MicroP/lab_descript/microp_lab_descriptions.html#lab-4-digital-audio",
    "title": "My Portfolio",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "MicroP/lab_descript/microp_lab_descriptions.html#lab-5-interrupts",
    "href": "MicroP/lab_descript/microp_lab_descriptions.html#lab-5-interrupts",
    "title": "My Portfolio",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "MicroP/lab_descript/microp_lab_descriptions.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "MicroP/lab_descript/microp_lab_descriptions.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "My Portfolio",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "MicroP/lab_descript/microp_lab_descriptions.html#lab-7-the-advanced-encryption-standard",
    "href": "MicroP/lab_descript/microp_lab_descriptions.html#lab-7-the-advanced-encryption-standard",
    "title": "My Portfolio",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "MicroP/lab_reflect/lab1/lab1.html",
    "href": "MicroP/lab_reflect/lab1/lab1.html",
    "title": "FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In Lab 1, the tasks included assembling the E155 protoboard, verifying the functionality of the MCU and FPGA, controlling a 7-segment display, and controlling onboard LEDs using SystemVerilog with Lattice Radiant. The lab was completed in approximately 8 hours.\n\n\n\nCompleted lab implementation\n\n\n\n\nAfter following the setup instructions from resources/course_website/Lab 1, a block diagram and circuit schematic was created to outline the SystemVerilog modules and signals for implementation. This step facilitated organization during the coding process.\n\n\n\nCompleted Micro Ps Protoboard\n\n\n\n\n\nThis lab involved implementing combinational logic for DIP-switch inputs, with a single 7-segment display showing hexadecimal digits (1-F) based on those inputs. Combinational logic blocks were implemented using case statements for XOR and AND operations, with outputs displayed on the onboard LEDs. The high-speed oscillator (HSOSC) was used to oscillate another onboard LED at approximately 2 Hz. Additionally, a case statement was used for the 7-segment display output, and pin assignments were meticulously configured in the device constraint editor in Lattice Radiant.\n\n\n\nBlock diagram outlining the SystemVerilog modules\n\n\n\n\n\nFor troubleshooting and debugging, manual test cases were used to verify that the correct segments illuminated as expected. A multimeter was also employed to ensure pins were functioning properly. These steps facilitated tracing issues to the software and effective code debugging.\n\n\n\nA full schematic outlining the lab’s hardware, including related signals and pins"
  },
  {
    "objectID": "MicroP/lab_reflect/lab1/lab1.html#intro-design-approach",
    "href": "MicroP/lab_reflect/lab1/lab1.html#intro-design-approach",
    "title": "FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In Lab 1, the tasks included assembling the E155 protoboard, verifying the functionality of the MCU and FPGA, controlling a 7-segment display, and controlling onboard LEDs using SystemVerilog with Lattice Radiant. The lab was completed in approximately 8 hours.\n\n\n\nCompleted lab implementation\n\n\n\n\nAfter following the setup instructions from resources/course_website/Lab 1, a block diagram and circuit schematic was created to outline the SystemVerilog modules and signals for implementation. This step facilitated organization during the coding process.\n\n\n\nCompleted Micro Ps Protoboard\n\n\n\n\n\nThis lab involved implementing combinational logic for DIP-switch inputs, with a single 7-segment display showing hexadecimal digits (1-F) based on those inputs. Combinational logic blocks were implemented using case statements for XOR and AND operations, with outputs displayed on the onboard LEDs. The high-speed oscillator (HSOSC) was used to oscillate another onboard LED at approximately 2 Hz. Additionally, a case statement was used for the 7-segment display output, and pin assignments were meticulously configured in the device constraint editor in Lattice Radiant.\n\n\n\nBlock diagram outlining the SystemVerilog modules\n\n\n\n\n\nFor troubleshooting and debugging, manual test cases were used to verify that the correct segments illuminated as expected. A multimeter was also employed to ensure pins were functioning properly. These steps facilitated tracing issues to the software and effective code debugging.\n\n\n\nA full schematic outlining the lab’s hardware, including related signals and pins"
  },
  {
    "objectID": "MicroP/lab_reflect/lab1/lab1.html#results-reflection",
    "href": "MicroP/lab_reflect/lab1/lab1.html#results-reflection",
    "title": "FPGA and MCU Setup and Testing",
    "section": "Results & Reflection",
    "text": "Results & Reflection\nThe design meets all the lab requirements at an acceptable level. However, accuracy in the LED oscillation could be improved. Currently, the LED oscillates based on the 25th bit of the high-speed oscillator (HSOSC), resulting in an approximate frequency of 2 Hz instead of the specified 2.4 Hz. To address this, a second counter would be implemented to track the exact oscillations from the HSOSC and adjust the LED to precisely 2.4 Hz.\nI particularly enjoyed learning Lattice Radiant, as it helped me reconnect with SystemVerilog concepts I had forgotten from E85.\nMoving forward, I will be more meticulous about reviewing and commenting my code. My initial Verilog code lacked sufficient comments, leading to confusion within the submodules. This lab taught me valuable code management techniques that I will apply from the start of Lab 2."
  },
  {
    "objectID": "MicroP/lab_reflect/lab1/lab1.html#technical-takeaways",
    "href": "MicroP/lab_reflect/lab1/lab1.html#technical-takeaways",
    "title": "FPGA and MCU Setup and Testing",
    "section": "Technical Takeaways",
    "text": "Technical Takeaways\n\nWhat to Remember\n\nEnsure that when assigning bits, they are prefaced by their respective size and base specifications.\nIf you encounter issues, double-check that the hardware is functioning as expected to rule out potential malfunctions.\n\n\n\nFor the Future\n\nLearn how to create and use a test bench."
  },
  {
    "objectID": "MicroP/lab_reflect/lab3/lab3.html",
    "href": "MicroP/lab_reflect/lab3/lab3.html",
    "title": "Keypad Scanner",
    "section": "",
    "text": "This lab utilized a 4x4 keypad scanner in tandem with a time-multiplexed dual 7-segment display, which was developed during Lab 2. The final goal was to update the right 7-segment display with each button press on the keypad, while the left display would show the previously pressed value. This functionality was implemented using a finite state machine (FSM) and next-state logic to simultaneously scan the keypad rows and decode which button was being pressed. Debouncing logic was also implemented to handle button bounce within the keypad.\n\n\n\nFigure1: Lab 3 hardware"
  },
  {
    "objectID": "MicroP/lab_reflect/lab3/lab3.html#hardware",
    "href": "MicroP/lab_reflect/lab3/lab3.html#hardware",
    "title": "Keypad Scanner",
    "section": "Hardware",
    "text": "Hardware\nThe system hardware consists of two main sections: segment control and keypad input. The segment control section is identical to the design from Lab 2, utilizing two 2N3906 PNP transistors and time-multiplexing logic to display two separate outputs on the dual 7-segment display. The keypad input section accesses the desired row and column pins. When a column is powered and a button is pressed in that column, a button press is registered if the corresponding row pin is active low.\nDue to the internal hardware of the keypad, when a column is powered and a key is pressed, the specific row being pressed is unknown, making it difficult to determine the exact button. To resolve this, a row-scanning method is used, which sets one row active low at a time using next state logic described in the FSM section. Since the column pins are active high, if a button is pressed in a column corresponding to an active low row, we can track which row is being scanned and which column pin is pulled down to 0, allowing us to accurately decode the button press.\n\n\n\nFigure2: Circuit diagram"
  },
  {
    "objectID": "MicroP/lab_reflect/lab3/lab3.html#fsm",
    "href": "MicroP/lab_reflect/lab3/lab3.html#fsm",
    "title": "Keypad Scanner",
    "section": "FSM",
    "text": "FSM\nTop Row States (Idle/Row Selection): This state acts as the pathway between all four row scans, determining which row is selected as active low. The FSM cycles through these top states rapidly when no button is pressed. Delay states are used between the top states to ensure button presses are registered in time.\nMiddle Row States (Button Detection/Decode): Upon detecting a button press, the FSM transitions from the top state to this second state for one clock cycle. Here, the button decoder is engaged, and the corresponding segment display values are updated. A delay state is used between the middle and bottom state to ensure segment values are assigned correctly.\nBottom Row States (Hold/Wait): After the button press is decoded, the FSM moves to the third state, which remains active as long as the button is pressed. No new logic occurs in this state, but it prevents further row scanning while a button is being held. This ensures that when one button is pressed, a second concurrent button press does not update the display.\n\n\n\nFigure3: Finite State Machine (FSM)"
  },
  {
    "objectID": "MicroP/lab_reflect/lab3/lab3.html#block-diagram",
    "href": "MicroP/lab_reflect/lab3/lab3.html#block-diagram",
    "title": "Keypad Scanner",
    "section": "Block Diagram",
    "text": "Block Diagram\nFigure 4 below displays the module communication logic for the System Verilog code that programmed the FPGA. Notibly we have a top, button_decode_bounce, and seven_seg_decoder modules.\ntop: The overseeing connection module and direct communication with I/O. Also includes the time-multiplexer and Low Speed Oscillator (LSOSC) clk source.\nbutton_decode_bounce: button decoder, debouncer, and row scan generator.\nseven_seg_decoder: decodes the button pressed into 7-segment display outputs.\n\n\n\nFigure4: System Verilog module block diagram"
  }
]